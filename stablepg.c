# include<stdlib.h>
# include<stdio.h>
# include<math.h>
# include<time.h>
# include<fcntl.h>
# include<unistd.h>
# include<stdint.h>
# include<omp.h>

# define S 100 //number of species evolving
# define T 20000000
    // storage limit: S*N = 10^8 would out put data of 1GB 
# define delay 0
# define N_sample 100
# define N_matrix 10
# define LEN 200 // the length of ourput trajectory (only when write_traj_judge used)
# define NUM_BYTES sizeof(uint32_t)

// model parameters
double mu = 4; //average value of a_ij
double sig = 1; //variance of a_ij
double mygamma = 0; //covariance factor of a_ij and a_ji
double r = 0.01; //= 2.5; // uniform growth rate of species.
// parameters to judge convergence
int N;
int interval = (1000 > (T/100)) ? 1000:(T/100); // time interval for convergence judgement
//double range = 0.00000000000001; // criteria for convergence
double range = 0.00000000000001;

int main(){
    // function claims
    void pairgenerate(double mean,double variance, double correlation, double* result1, double* result2); //function to generate correlated random number pair
    int matrix_generate(double a[S][S], double sig);
    int evolve(double** Nt, double a[S][S]);
    int converge(double** Nt);
    void write_traj(double** Nt);
    N = T;
    printf("r=%LF, mu=%LF, sig=%LF, T=%d, delay=%d, S=%d\n",r, mu, sig, T, delay, S);

    //allocate memory space for huge array Nt. Nt[i][t] is the abundance of species i at time t
    
    double **Nt;
    Nt = (double **)malloc(S * sizeof(double *));
    for (int b = 0; b < S; b++) {
        Nt[b] = (double *)malloc(interval * sizeof(double));
    }
    
    double a[S][S]; // array to store matrix A
    if (matrix_generate(a, sig)== -1){
        return 0;
    }

    if(evolve(Nt, a)){
        printf("error\n");
        return 0;
    }
    
    if(converge(Nt)){
        printf("not converging\n");
        write_traj(Nt);
        return 0;
    }

    char pname[50];
    sprintf(pname, "p_S%d_mu%.0Lf_sig%.0Lf_gamma%.0Lf.csv", S, mu, sig, mygamma);
    FILE *pfile = fopen(pname, "w");
    for(int i = 0; i<S; i++){
        fprintf(pfile, "%.15Lf", Nt[i][(N-1)%interval]);
        if(i<S-1){
            fprintf(pfile, ",");
        }
    }
    fprintf(pfile, "\n");
    fclose(pfile);

    
    // release the memory reserved for array Nt
    
    for (int i = 0; i < S; i++) {
        free(Nt[i]);
    }
    free(Nt);
    return 0;
}

// Function to generate related Gaussian random numbers (Acknowledgement: this function is originally generated by ChatGPT3.5 and further modefied by the author)
void pairgenerate(double mean, double variance, double correlation, double* result1, double* result2) {
    // Generate independent standard normal random numbers using Box-Muller transform
    double u1 = ((double)(rand()+1) / (RAND_MAX+1));
    double u2 = ((double)(rand()+1) / (RAND_MAX+1));
    double z1 = sqrt(-2.0 * log(u1)) * cos(2.0 * M_PI * u2);
    double z2 = sqrt(-2.0 * log(u1)) * sin(2.0 * M_PI * u2);
    // Linear transformation to obtain correlated Gaussian random numbers
    *result1 = mean + sqrt(variance) * z1;
    *result2 = mean + (correlation  * (z1)) + sqrt(variance - correlation * correlation) * z2;
}

int matrix_generate(double a[S][S], double sig){
    void pairgenerate(double mean,double variance, double correlation, double* result1, double* result2); //function to generate correlated random number pair
    char aname[50]; // string as file name to store matrix A
    sprintf(aname, "a_S%d_mu%.0Lf_sig%.0Lf_gamma%.0Lf.csv", S, mu, sig, mygamma);
    //printf("Do you want to load an existing matrix?(1 for yes, 0 for no)\n");// to ask if the program should generate a nex random matrix or loading an existing one from a file.
    int choice; // parameter to show the choice
    //scanf("%d", &choice);
    choice = 0;
    if (choice == 0){ // to generate a new random matrix
        double rd1, rd2;// variable pair to store random number pair generated
        // go over the matrix and set values for a_ij
        srand((unsigned int)time(NULL));
        for(int i=0; i<S; i++){
            for (int j=0; j<i; j++){
                pairgenerate(0, (double)1/S, mygamma/S, &rd1, &rd2);
                a[i][j] = mu/S + sig*rd1;
                a[j][i] = mu/S + sig*rd2;
            }
            a[i][i] = 1;
        }
        // store the matrix generated in a CSV file for future use
        
        FILE *afile = fopen(aname, "w");
        for(int i=0; i<S; i++){
            for(int j=0; j<S; j++){
                fprintf(afile, "%.15Lf", a[i][j]);
                if (j < S-1){
                    fprintf(afile, ",");
                }
            }
            fprintf(afile, "\n");
        }
        fclose(afile);
    } else if (choice == 1){ // to load in an existing matrix
        FILE *efile = fopen(aname, "r");
        if(efile == NULL){ // error report for failing to open/find the file
            printf("Unable to load file %s\n", aname);
            return -1;
        }
        // load in the values of a_ij
        int i = 0, j = 0;
        char comma;
        char ret = ',';
        while (ret != EOF && i<S){
            for(j=0; j<S; j++){
                fscanf(efile, "%Lf", &a[i][j]);
                ret = fscanf(efile, "%c", &comma);
            }
            i++;
        }
        fclose(efile);
    } else { // to warn the user that there is an invalid input
        printf("Invalid input, program ends\n");
        return -1;
    }
    return 0;
}

int evolve( double** Nt, double a[S][S]){
    double convertBytesToDouble(const unsigned char *bytes);
    for(int s = 0; s<S; s++){
        for(int t =0; t<interval; t++){
            Nt[s][t] = 0;
        }
    }
   // generate the initial values of each species

    srand((unsigned int)time(NULL)); // set the random seed again
    for(int s=0; s<S; s++){
        Nt[s][0] = 0.1 * (double)rand() / RAND_MAX; // random initial value between 0 and 1
        //printf("N%d=%Lf\n",s, Nt[s][0]);
    }
    
    /*
    int fd;
    unsigned char random_bytes[NUM_BYTES];
    fd = open("/dev/random", O_RDONLY);
    for (int s = 0; s < S; s++){
        read(fd, random_bytes, NUM_BYTES);
        Nt[s][0] = convertBytesToDouble(random_bytes) * 0.1;
    }
    close(fd);
    */
    // Evolution according to LV model
    int t = 1;
    int Ext[S]; // array to record if the species have been extinct
    int toExt[S];
    int change = 0;
    for(int i=0; i<S; i++){
        Ext[i] = 1;
        toExt[i] = 1;
    }
    // In the case of time delay, we ignore the competition effect before the delay data exist
    for(;t < delay + 1; t++){
        for (int i=0; i<S; i++){
            Nt[i][t] = (1+r)*Nt[i][t-1];
        }
    }
    register double sum; // put sum into register to speed up
    for(; t<N; t++){
    for(int i=0; i<S; i++){
        if(Ext[i]){
        // sum over the competition effects
        sum = 0.0;
        for(int j=0; j<S; j++){
            if(Ext[j]){
                sum += a[i][j]*Nt[j][(int) (t-1-(int) (delay))%interval]*Nt[i][(int) (t-1)%interval];    
        }}
        // evolution
        Nt[i][(int) t%interval] = Nt[i][(int) (t-1)%interval]+ r*(-sum + Nt[i][(int) (t-1)%interval]);
        // Kill the program when abnormal behaviour of N_i is found and report the situation
        if (Nt[i][(int) t%interval]>100000){ 
            //printf("blow up \n");
            printf("i=%d, N=%Lf", i, Nt[i][(int) t%interval]);
            return -1;
        }
        if (Nt[i][(int) t%interval]<range){
            //printf("error: negative abundance \n");
            //return -2;
            Nt[i][t%interval] = 0;
            toExt[i] = 0;
            change = 1;
        }
    }
        }
        if(change){
            for(int i=0; i<S; i++){
                Ext[i] = toExt[i];
            }
        }
        change = 0;
    }
    for(int s=0; s<S; s++){
        if(Ext[s]==0){
            for(int m = 0; m<interval; m++){
                Nt[s][m] = 0;
            }
        }
    }
    return 0;
}

int converge(double** Nt){
    // convergence judgement
    int status = 0; // variable to store the number of species that have not converged
    for (int s = 0; s<S; s++){
        for (int td = 0; td<interval; td++ ){
        if(Nt[s][(int) (N-1)%interval] - Nt[s][(int) (N-2 - td)%interval]>=range || Nt[s][(int)(N-2 - td)%interval] - Nt[s][(int)(N-1)%interval] >= range){// to see if the change on abundance of species i over the interval is within the range set before
            status++;
        }  
    }}
    return status;
}

void write_traj(double** Nt){
    char dname[50]; // spring for data file name
    sprintf(dname, "d_S%d_T%.0e_del%d_r%.1Le.csv", S, (double)T, delay, r);
    FILE *dfile = fopen(dname, "w");
    // write in the time evolution data
    for (int k = 0; k<interval; k++){
        for (int l = 0; l<S; l++){
            fprintf(dfile, "%.15Lf", Nt[l][(N-interval+k)%interval]);
            if (l < S-1){
                fprintf(dfile, ",");
            }
        }
        fprintf(dfile, "\n");
    }
    fclose(dfile);
}

double convertBytesToDouble(const unsigned char *bytes){
    uint32_t result = 0;
    for (size_t i = 0; i < NUM_BYTES; i++){
        result |= bytes[i] << (8*i);
    }
    return (double)result/ ((double)UINT32_MAX + 1);
}
